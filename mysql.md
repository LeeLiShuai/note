**sql语句执行过程**

sql语句执行，连接池链接，分析语法，查询缓存，优化器优化sql语句，执行器执行语句。



**mysql逻辑分层**

1.连接层，提供与客户端连接的服务

2.服务层，缓存查询，解析器，优化器。

3.引擎层，负责数据存储，存储引擎不同，存储方式，数据格式，提取方式也不同

4.存储层，存储数据，文件系统



**三范式**

第一范式：列都是不可再分的，保证列的原子性，如果每列都是不可再分的最小数据单元，则满足第一范式

第二范式：满足第一范式，且表中非主键列不出存在对主键的依赖，要求每个表只描述一件事情

第三范式：满足第二范式，并且表中的列不存在对非主键列的传递依赖，非主键间不存在依赖关系。如订单表中存着客户编号符合第三范式，存着客户姓名则不符合第三范式



**事务隔离级别**

事务的四个属性：

原子性Atomicity：事务时一个完整的操作，全部成功或全部失败

一致性Consistency:事务完成时，数据必须处于一致状态,事务开始之前和结束之后，诗句哭的完整性约束没有被破坏

隔离性Isolation:对数据进行修改的所有并发事务彼此隔离，没有依赖关系

持久性Durability：事务完成后，对数据库的修改被永久保持。



隔离级别

读未提交READ-UNCOMMITTED：事务可以读到其他事务未提交的数据变更，可能导致脏读，不可重复度，幻读

读已提交READ-COMMITTED：事务执行过程中，可以读取到其他事务已提交的数据，可以防止脏读，会出现不可重复读，幻读

可重复读REPEATABLE-READ：对一个字段的对此读取结果是一致的，除非数据被本事务修改，可防止脏读，不可重复读，会出现幻读

序列化SERIALIZABLE:所有事务依次执行，可以防止以上三种

脏读：事务A读取了事务B修改的数据，然后B回滚了，A读到的是脏数据

不可重复度：事务A多次重复读取一条数据，事务B修改了这条数据，A两次读取到的数据不一致

幻读：事务A查询到N行数据，事务B插入一条。事务A又查到N+1条



**redolog,undolog,binlog的区别**

redolog,undolog存在于innodb中，统称为事务日志。

undolog用于回滚，事务未提交，改动没有全部生效，记录被部分修改，设备宕机，需要依靠undolog修复数据

redolog,事务提交后，部分数据写入磁盘，还有部分未写入，设备宕机，需要依靠redolog修复

binlog，归档日志，用于复制，主从同步，记录所有表数据结构变更和数据变更，不记录查询语句。



**多版本并发控制**



**索引**

索引是一种帮助MYSQL快速获取数据的数据结构

索引一般数据结构为B+树，索引也是一张表，除主键索引外，其他索引保存了主键和索引字段，并指向实体表的记录。索引提高了查询的速度，降低了新增修改删除的速度，要维持索引的排序



B树与B+树的区别：

1.B+树非叶子结点不存具体数据，数据保存在叶子节点中

2.B+树所有叶子结点间有一个链指针，所以B+树适合随机访问和顺序访问，B树适合随机访问

3.B+树空间利用率高，节点的大小是固定的，非叶子结点不存储数据，可以存储更多的key，降低树的深度。



需要创建缩印的情况

1.主键自动创建唯一索引

2.频繁作为查询条件的字段

3.与其他表进行关联的字段

4.组合索引替代多个索引

5.查询中的排序字段

6.查询中统计或分组字段



不需要创建索引

1.数据太少

2.经常增删改的字段

3.数据重复且均匀的字段

4.频繁更新的字段



覆盖索引：

select的数据列从索引中就能够获得，不需要会标



**explain**

explain+SQL查看SQL执行计划

会出现几行数据

id:查询的序列编号，包含一组数组，表示查询中执行的顺序，

​	id大的先执行，id相同时，从上往下执行

select_type:查询类型

​	simple：简单的查询

​	primary:如果查询中包含复杂的子部分，最外层被标记为primay

​	subquery:在select或where列表中包含了子查询

​	derived:在from列表中包含的子查询被标记为derived，MySQL会递归的执行子查询，把	结果放到临时表中

​	union：union之后的查询语句，被标记为union，如果union包含在from子句的子查询	中，外层select被标记为derived

​	union result：从union表中获取的结果的select

table：这行数据是属于哪张表的

type：查询使用了那种类型，从好到差system->const->eq_ref->fulltext->ref_or_null->index_merge->unique_subquery->index_subquery->range->index->ALL

​	system:表只有一行记录

​	const：通过一次索引就找到了，获取主键列或唯一索引列

​	eq_ref:唯一索引扫描，对于每个索引建，表中只有一条数据匹配，常见于主键或唯一索	引扫描

​	ref:非唯一性索引扫描，范围匹配某一单独值的所有行，

​	range:只检索给定范围的行，使用一个索引来选择行，key列显示使用了哪个索引，范围	扫描索引好于全表扫描

​	index：索引全表扫描，遍历索引树，

​	ALL：数据全表扫描

possible_keys:可能使用到的索引列

key:实际使用到的索引

key_len:索引使用的长度

ref:索引的哪一列被使用了，如果可能的话是一个常数

rows:大致读取的行数

Extra:额外信息

​	using filesort:

**MySQL锁机制**

对数据的操作类型分类：

读锁和写锁：对同一份数据，多个读可以同时操作，写会阻断其他读和写

对数据操作的粒度分类：

表级锁：开销小，加锁快，不会出现死锁；锁粒度大，发生冲突概率大，并发度低，MyISAM和MEMORY存储引擎使用表级锁

行级锁：开销大，加锁慢；会出现死锁，锁粒度最小，冲突概率低，并发高，InnoDB支持行级锁和表锁，默认采用行级锁

页面锁：介于上面两者之间，会出现死锁。