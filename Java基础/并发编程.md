**线程与进程**

进程是操作系统运行程序的基本单位。

线程是比进程更小的单位，一个进程可能包含多个线程，JAVA中一个进程中的线程共享堆内存和元空间的内存，每个进程有自己的程序计数器，虚拟机栈，本地方法栈。



**并发与并行**

并发是一个时间段内，有多个任务执行，并不一定是同一个时刻

并行是同一时刻，多个任务同时执行



**线程生命周期和状态**

New:新城被构建，但是没有调用start方法

Ready:调用start后处于ready状态

Running:ready状态的线程获得时间片后处于运行状态

Blocked:阻塞状态，等待进入同步代码块

Waitting:等待状态，Object.wait(long),Thread.join(long),LockSupport.parkNanos()

Time_Waitting:超时等待，等待一段时间后自动返回，

Thread.sleep(long),Object.wait(long),Thread.join(long),LockSupport.parkNanos(),LockSupport.parkUnit()

Terminated:终止状态，执行完毕



**sleep和wait的区别**

sleep没有释放锁，wait释放锁

都暂停线程的执行，wait用于线程间通信，wait被调用后，需要其他线程调用同一对象的notify或notifyAll,sleep方法执行完后，线程自动苏醒，或者过了执行时间自动苏醒





**volatile**

1.可见性：java每个线程都有自己的工作内存，还有一块共享的主内存。

普通情况下，线程会从主内存复制变量到自己的工作内存，然后进行计算，

距离cpu更近，速度更快。但是这样会产生线程安全问题，两个线程同时修改自己工作内存里的值，然后写回主内存，会相互覆盖，多个线程并发读写共享变量的可见性问题。

使用volatile修饰的变量，当线程修改变量的值时，强制将最新的值刷新到主内存，保持主内存的值为最新，同时使其他线程中的本地内存里的缓存失效，让其重新从主内存获取。

2.防止指令重排序：编译器优化重排(jvm中进行)，指令级并行重排，cpu重排

 经典用例双重检验锁定,synchronized只保证只有一个线程执行代码段，不保证代码块内的程序补充排序，因为对于单线程，重排是没有影响的。synchronized保证在释放锁的同时，线程工作内存的值刷新会主内存，并不一定是释放的时候同步，可能释放之前就同步了。对象初始化分为三步，分配内存，把对象分配到内存中，将instance指向内存。

在重排的情况下，23可能会颠倒，此时instance指向的是不是null,但是对象是没有值的。如果此时工作内存同步到主内存，其他线程在第一个if读取到的instance就不是null，直接返回一个空对象。

```
private volatile static Instance instance;

if (instance == null) {
            synchronized (Singleton.class ) {
                if (instance == null)
                    instance = new Instance();
            }
        }
```





**Happens-before**

As-if-serial：程序在单线程的情况下，会发现重排序，但是重排序不会改变以来关系，最终的结果与不重排序是一样的

但是在多线程的情况下，就不一定了。JMM提供了几条规则，让我们可以根据规则推导多线程的内存可见性，不用去理解底层从排序的规则。

Happens-before:如果A线程的写操作happens-beforeB线程的读操作，尽管AB两个不同线程，但是JMM保证A的写操作对B可见。即 A happens-before B,则A的执行结果对B可见，且A的执行顺序在B之前。

1.程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作

2.监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁

3.volatile变量规则:对volatile的变量的写，happens-before于任意后续对这个volatile的读

4.传递性

5.start规则:在A中执行b.start(),则这个start操作happens-before于b线程里的操作

6.join规则:A中执行b.join,则b中的操作happens-before于a之后的操作

7.程序中断规则：对线程interrupetd()方法的调用happens-before被中断线程的代码检测到中断时间的发生

8.对象fiinalize规则:对象的初始化完成happens-before于finalize()的执行



**Synchorized**

synchorized可以保证方法或代码块在运行时，同一时刻只有一个线程可以进入到临界区，同时保证共享变量的可见性。

修饰实例方法：锁的对象是当前对象

修饰静态方法：锁当前class对象

修改代码块：锁括号里的对象



**Synchronized与Lock对比**

|          | Synchronized | Lock                   |
| -------- | ------------ | ---------------------- |
| 实现方式 | JVM          | API                    |
| 灵活性   | 不灵活       | 可中断，超值，尝试获取 |
| 释放形式 | 自动释放     | 调用unlock             |
| 锁类型   | 非公平       | 公平&非公平            |
| 可重入   | 可           | 可                     |



**Synchronized与Volatile**

Volatile保证数据的可见性，防止重排序，不能保证原子性，synchronized都可以

volatile为了解决变量在多个线程之间的可见性，synchronized为了解决多个线程访问资源的同步性

volatile不对阻塞线程，synchronized会阻塞线程



**死锁**

死锁产生的条件：

1.互斥：资源在任意时刻只能由一个线程占用

2.占有且等待：一个线程请求资源而阻塞时，不会放弃已经占用的资源

3.不可强行占有：不能抢占其他线程的资源

4.循环等待：循环等待



避免死锁：

1.破坏互斥：无法破坏，目的就是互斥

2.破坏占有且等待：一次性申请所有资源，不用等待

3.破坏不可强行占用：申请不到全部资源时，主动释放资源

4.破坏循环等待：按照顺序申请资源



排查死锁

Jps找到端口号

jstack pid



死锁预防：

以确定的顺序获得锁，如果要获取多个锁，以固定的顺序获取

超时放弃，synchronized会一直阻塞，直到获取锁，可以使用Lock按照固定时间获取锁



**线程间共享数据**

1.将数据抽象成一个类，并将数据的操作作为这个类的方法

2.runnable对象作为一个类的内部类，共享数据作为类的成员变量，每个线程对变量的操作也封装在外部类，runnable作为内部类调用这些方法



**ThreadLocal**

存储每个线程的私有数据

Thread类内部有个ThreadLocalMap对象，类似于HashMap,key为ThreadLocal实例，

Value是线程持有的对象。key为弱引用，value为强引用。 



**CAS**

Compare And Swap/Set

包含三个参数CAS(V,E,N),v表示变量，E表示预期值(旧值，即当前值)，N表示新值

当V的值为E的时候，把他重新赋值为N.如果V的值不为E,什么都不做。

CAS的操作是抱着乐观的态度进行的，总是认为自己的操作可以完成，当多个线程同时进行CAS操作时，只有一个会成功，其他都会失败。失败的线程不会被挂起，只是被告知失败，可以继续尝试，也可以放弃操作，基于这样的原理，CAS操作即使没有锁，也可以发现其他线程对当前操作的干扰，并进行处理

ABA问题，可能出现一种情况，A线程认为当前值时A,但是期间发生了两次修改，先修改为B,又修改为A,是符合A的条件的，但是值已经发生了两次变化。有些场景下时不符合业务逻辑的，此时可以加上版本号或时间戳进行标示。



**Atomic**

java.util.concurrent.atomic包下提供了一组原子类。在多线程环境下，多个线程同时执行这些类的方法时，具有排他性。A线程执行方法时，不会被B线程打断，B线程会自旋等待A执行完毕再执行atomic的方法。



**同步与异步，阻塞与非阻塞**

系统IO分为两个部分，等待就绪和实际执行操作。读函数分为等待系统可读和真正的读。写函数分为等待系统可写和真正的写。

第一步是不使用CPU的，第二部是使用CPU的。

阻塞IO两步都是阻塞的

非阻塞IO，在第一步一直轮询直到第二步可以进行操作

IO复用，一个单独的线程轮询检查多个IO操作，只占用一个线程

信号驱动IO,第一步直接返回，完成后通知线程进行第二步

异步IO，第一步直接但会，所有操作完成后通知线程

几种IO除了异步IO,其他的第二步都是阻塞的

BIO会阻塞在第一步，等待数据准备就绪

Java网络编程中，BIO的read,write是同步阻塞的，想要支持多个客户端连接，只能每个连接起一个线程，每个线程读写时都是阻塞的，连接多了服务器无法承受。

NIO是同步非阻塞的，每个连接都注册时间到时间处理器



**多线程打印问题**

两个线程：wait和notify

大于两个：wait和nofifyAll