**什么是分布式事务**

分布式事务是指事务的参与者，支持事务的服务器，资源服务器，事务管理器位于分布式系统的不同节点上。

一次操作由几个步骤组成，步骤又分布在不同的服务器上，属于不同的应用。

分布式事务=多个本地事务，通过事务管理器，达到多个本地事务要么全部成功，要么全部失败，保证不同数据库的数据一致性。



**CAP**

C:一致性，在分布式系统中的所有数据备份，在同一时刻是同样的值，等同于所有节点访问同一份最新的数据

A:可用性，在集群中部分节点故障后，集群整体还能相应客户端的读写请求，对数据更新具备高可用性

P:分区容错性，在不稳定和不可靠的网络环境下，节点可能出现失联或者宕机，网络可能出现分区子网，在这种情况下仍然能保证数据不出错。

CA:单机系统可以是CA,应为只有一个节点，不存在分区的情况。

CP:不要求可用性，每个请求都在server间强一致，P会导致同步时间不可控。

AP:分区发生时，节点间可能失去联系，为了高可用，每个节点用本地数据提供服务，会导致全部数据不一致性

MySQL 主从异步复制是 AP 系统。

MySQL 主从半同步复制是 CP 系统。

Zookeeper 是 CP 系统。

Redis 主从同步是 AP 系统。

Eureka 主从同步是 AP 系统。



**BASE**

BA:基本可用，分布式系统出现故障时，允许损失部分可用功能，保证核心功能可用

S:软状态，允许系统存在中间状态，允许系统暂时的数据不一致

E:最终一致，经过一段时间后，所有的节点数据将会达到一致、

XA协议是强一致性的，其他基本都是最终一致性



**分布式事务方案**

XA方案

两阶段提交的强XA:将分布式事务的提交拆分为2个阶段，prepare和commit/rollback。

第一阶段:准备，事务管理器要求每个数据库预提交操作，并返回是否可以提交

第二阶段:提交或回滚，事务管理器要求每个数据库提交数据，或者回滚数据

开启XA全局事务后，所有子事务按照本地的隔离级别锁定资源，并记录undo和redo日志，然后由事务管理器发起prepare投票，

询问所有子事务是否可以进行提交。所有子事务返回可以提交时，事务管理器发起提交，如果有子事务返回不能提交，则事务管理器发起回滚。如果第二阶段提交过程中宕机，重启后可以根据日志进行数据修复

优点：尽量保证了数据的强一致，实现成本低

缺点：如果事务管理器在第二阶段宕机，则资源管理器会一直阻塞。 在准备就绪后，资源管理器中的资源一直处于阻塞状态

数据不一致，第二阶段网络问题仅部分资源管理器执行了提交操作。其余参与者会一致处于阻塞状态。

依赖于数据库，高并发量较低。



TCC

将锁的粒度交给业务处理，需要每个子事务业务事项try confirm cancel接口。

try:尝试执行业务，完成所有业务检查，预留资源

confirm:确认执行业务，真正执行业务，不做检查，只使用try阶段预留的资源，满足幂等性

cancel:取消执行业务，释放try预留的资源，满足幂等性

对业务网侵入性强，改造难度大



本地消息表

AB两个系统，A调用B

1.A在自己本地一个事务里操作的同时，插入一条数据到消息表

2.A发送这个消息到MQ

3.B消息这条消息，在一个事务里往自己本地消息表里插入一条数据，同时执行其他业务操作，如果这个消息被处理过了，此时事务回滚，保障不会重复处理消息

4.B执行成功后，更新自己本地消息表里的状态和A系统消息表的状态

5.如果B执行失败，不会更新状态消息表，A定时扫描自己的消息表，如果有未处理的消息，再次发现送到MQ中，让B处理

6.保证最终一致性，B失败了，A会不断地重发，直到成功。

依赖数据库的消息表



可靠消息最终一致性

不用本地消息表，基于MQ实现业务，rocketMQ支持事务消息

1.A发送一个prepare消息到mq,如果发送失败，直接取消操作

2.消息发送成功，A执行本地事务，成功了就通知mq发送确认消息，失败通知mq回滚

3.发送了确认消息，B收到确认消息，执行本地事务

4.mq自动定时轮询所有prepared消息回调A,询问是否A的本地事务失败，没有发送消息，是重试还是回滚，

A检查数据库，查看事务是否执行，如果没执行，通知mq回滚。

5.B如果消费失败，会一直消费，直到成功或人工手动回滚



最大努力通知

1.A本地事务执行完之后，发送消息到mq

2.有一个消费mq的最大努力通知服务，消费mq然后写入数据库中记录下来，然后调用b接口

3.如果b执行失败，最大努力通知服务定时重新调用b，反复n次，最后还是不行就放弃。



saga

