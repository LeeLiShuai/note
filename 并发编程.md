**线程与进程**

进程是操作系统运行程序的基本单位。

线程是比进程更小的单位，一个进程可能包含多个线程，JAVA中一个进程中的线程共享堆内存和元空间的内存，每个进程有自己的程序计数器，虚拟机栈，本地方法栈。



**并发与并行**

并发是一个时间段内，有多个任务执行，并不一定是同一个时刻

并行是同一时刻，多个任务同时执行



**线程生命周期和状态**

New:新城被构建，但是没有调用start方法

Ready:调用start后处于ready状态

Running:ready状态的线程获得时间片后处于运行状态

Blocked:阻塞状态，等待进入同步代码块

Waitting:等待状态，Object.wait(long),Thread.join(long),LockSupport.parkNanos()

Time_Waitting:超时等待，等待一段时间后自动返回，

Thread.sleep(long),Object.wait(long),Thread.join(long),LockSupport.parkNanos(),LockSupport.parkUnit()

Terminated:终止状态，执行完毕



**sleep和wait的区别**

sleep没有释放锁，wait释放锁

都暂停线程的执行，wait用于线程间通信，wait被调用后，需要其他线程调用同一对象的notify或notifyAll,sleep方法执行完后，线程自动苏醒，或者过了执行时间自动苏醒





**volatile**

1.可见性：java每个线程都有自己的工作内存，还有一块共享的主内存。

普通情况下，线程会从主内存复制变量到自己的工作内存，然后进行计算，

距离cpu更近，速度更快。但是这样会产生线程安全问题，两个线程同时修改自己工作内存里的值，然后写回主内存，会相互覆盖，多个线程并发读写共享变量的可见性问题。

使用volatile修饰的变量，当线程修改变量的值时，强制将最新的值刷新到主内存，保持主内存的值为最新，同时使其他线程中的本地内存里的缓存失效，让其重新从主内存获取。

2.防止指令重排序：编译器优化重排(jvm中进行)，指令级并行重排，cpu重排

 经典用例双重检验锁定,synchronized只保证只有一个线程执行代码段，不保证代码块内的程序补充排序，因为对于单线程，重排是没有影响的。synchronized保证在释放锁的同时，线程工作内存的值刷新会主内存，并不一定是释放的时候同步，可能释放之前就同步了。对象初始化分为三步，分配内存，把对象分配到内存中，将instance指向内存。

在重排的情况下，23可能会颠倒，此时instance指向的是不是null,但是对象是没有值的。如果此时工作内存同步到主内存，其他线程在第一个if读取到的instance就不是null，直接返回一个空对象。

```
private volatile static Instance instance;

if (instance == null) {
            synchronized (Singleton.class ) {
                if (instance == null)
                    instance = new Instance();
            }
        }
```





**Happens-before**

As-if-serial：程序在单线程的情况下，会发现重排序，但是重排序不会改变以来关系，最终的结果与不重排序是一样的

但是在多线程的情况下，就不一定了。JMM提供了几条规则，让我们可以根据规则推导多线程的内存可见性，不用去理解底层从排序的规则。

Happens-before:如果A线程的写操作happens-beforeB线程的读操作，尽管AB两个不同线程，但是JMM保证A的写操作对B可见。即 A happens-before B,则A的执行结果对B可见，且A的执行顺序在B之前。

1.程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作

2.监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁

3.volatile变量规则:对volatile的变量的写，happens-before于任意后续对这个volatile的读

4.传递性

5.start规则:在A中执行b.start(),则这个start操作happens-before于b线程里的操作

6.join规则:A中执行b.join,则b中的操作happens-before于a之后的操作

7.程序中断规则：对线程interrupetd()方法的调用happens-before被中断线程的代码检测到中断时间的发生

8.对象fiinalize规则:对象的初始化完成happens-before于finalize()的执行



**Synchorized**

synchorized可以保证方法或代码块在运行时，同一时刻只有一个线程可以进入到临界区，同时保证共享变量的可见性。

修饰实例方法：锁的对象是当前对象

修饰静态方法：锁当前class对象

修改代码块：锁括号里的对象



**Synchronized与Lock对比**

|          | Synchronized | Lock                   |
| -------- | ------------ | ---------------------- |
| 实现方式 | JVM          | API                    |
| 灵活性   | 不灵活       | 可中断，超值，尝试获取 |
| 释放形式 | 自动释放     | 调用unlock             |
| 锁类型   | 非公平       | 公平&非公平            |
| 可重入   | 可           | 可                     |



**Synchronized与Volatile**

Volatile保证数据的可见性，防止重排序，不能保证原子性，synchronized都可以

volatile为了解决变量在多个线程之间的可见性，synchronized为了解决多个线程访问资源的同步性

volatile不对阻塞线程，synchronized会阻塞线程



**死锁**

死锁产生的条件：

1.互斥：资源在任意时刻只能由一个线程占用

2.占有且等待：一个线程请求资源而阻塞时，不会放弃已经占用的资源

3.不可强行占有：不能抢占其他线程的资源

4.循环等待：循环等待



避免死锁：

1.破坏互斥：无法破坏，目的就是互斥

2.破坏占有且等待：一次性申请所有资源，不用等待

3.破坏不可强行占用：申请不到全部资源时，主动释放资源

4.破坏循环等待：按照顺序申请资源



排查死锁

Jps找到端口号

jstack pid



死锁预防：

以确定的顺序获得锁，如果要获取多个锁，以固定的顺序获取

超时放弃，synchronized会一直阻塞，直到获取锁，可以使用Lock按照固定时间获取锁



**ThreadLocal**

存储每个线程的私有数据

Thread类内部有个ThreadLocalMap对象，类似于HashMap,key为ThreadLocal实例，

Value是线程持有的对象。key为弱引用，value为强引用。 



**Atomic**

