**几种数据结构**

**String**

set  key  value,value最大能存储512M

使用场景：弹窗每天弹一次，缓存不常修改的数据，

限定ip访问次数，session共享



**Hash**

hset key field value

缓存对象信息



**List**

lpush key value1 value2 ... valueN

rpush key value1 value2 ... valueN

列表信息



**Set**

sadd key value1 value2 ... valueN

收藏夹，去重



**Sorted Set**

zadd key socre1 value1 ... scoreN vluaeN

排行榜



**持久化**

将内存的数据转移到硬盘上的过程叫做持久化。防止应用或机器意外关闭丢失数据。

RDB:指定时间间隔对数据进行快照存储，可手动触发，自动触发。

手动触发save,不推荐使用，会阻塞Redis直到备份完成.bgsave，

自动触发，配置文件中 save second changes，xx秒内有xx次改动时触发bgsave。

AOF:每次对服务器的写操作时，追加记录到AOF文件中。



**bgsave**

流程：1.执行bgsave命令，redis进程判断是否有正在执行的子进程，如果有直接返回

2.redis进程fork一个子进程，fork操作会阻塞redis进程，

3.fork完成过后，bgsave返回background saving started,不再阻塞Redis进程

4.子进程创建rdb文件，根据父进程内存生成临时快照文件，替换原有文件

5.通知Redis进程备份完成



**aof**

配置文件中 appendonly yes，默认情况下未开启

文件名 appendfilename，默认appendonly.aof

流程：1.所有写命令追加到缓冲区中

2.缓冲区根据策略向硬盘做同步操作(每次操作，一秒一次(常用)，由操作系统控制)

3.定期对aof文件进行重写



重写：为了减少文件占用，重启时更快的加载

手动触发，bgrewriteaof

自动触发，auto-aof-rewrite-min-size,auto-aof-rewrite-percentage.到一定大小(默认64M),或者当前文件大小与上下次重写后aof文件的大小大于一定比值时自动触发。



**重启时加载数据**

1.开启了AOF,且存在AOF文件，优先加载AOF文件

2.不符合1，加载RDB文件



**两种备份方式对比**

RDB:保存了某个时间点的数据集，恢复更快，适用于灾难恢复，全量复制

发生意外丢失数据较多，数据大时，fork耗时



AOF:数据丢失少，配置每秒刷盘一次，最多丢失1秒数据

文件大小大于RDB,加载较慢



**线程模型**

文件时间处理器，io多路复用同时监听多个socket,根据socket上的时间选择对应的时间处理器处理。纯内存操作，非阻塞多路复用，避免多线程频繁上下文切换



**缓存穿透**

用户请求的数据在缓存中不存在，未命中缓存，且在数据库中也不存在，导致用户每次请求数据都请求数据库，然后返回空。

解决方法：

布隆过滤器：检验某个元素是否在一个集合中，一定不存在或可能存在。

返回空对象：缓存未命中，数据库查询为空，将空值写到缓存中，设置一个过期时间。

可能会浪费内存，短时间数据不一致



**缓存击穿**

热点key失效，大量请求数据库。

解决方法：

互斥锁：一个线程写缓存，其他线程等待缓存线程执行完，重新读取缓存，减低吞吐量

热点数据不过期：热点数据设置过期时间较长，且定时更新数据



**缓存雪崩**

一定时间内大批缓存过期，直接请求数据库

解决方法：

均匀过期:设置不同的缓存过期时间

互斥锁:同缓存击穿

永不过期:同缓存击穿



**内存淘汰机制**

配置文件 maxmemory  1024mb，默认为0，最大内存为系统剩余内存

淘汰策略：

noeviction:默认策略，写请求返回错误，不淘汰

allkeys-lru:从所有的key中使用LRU算法进行淘汰

volatile-lru:从设置了过期时间的key中使用LRU算法进行淘汰

allkeys-random:从所有key中随机淘汰

volatile-random:从设置了过期时间的key中随机淘汰

volatile-ttl:从设置了过期时间的key中，越早过期的优先被淘汰

allkeys-lfu:从所有可以中根据最少使用频率进行淘汰

volatile-lfu:从设置了过期时间的key根据最少使用频率进行淘汰

Volatile-X策略中，如果所有key都没设置过期时间，则返回错误

redis的lru维护一个大小为16的候选池，根据最近访问时间进行排序，第一次随机选择5个可以放入池中，

随后每次随机选择的key只有访问时间小于池中最小的时间的才会放到池中，直到放满，需要淘汰时，

从池中选择最近访问时间最小的key进行淘汰。



**过期删除策略**

**定时删除**：

在设置键的过期时间的同时，创建一个定时器(timer)，让定时器在键的过期时间来临时，立即执行对键的删除操作；对内存是最友好的：通过使用定时器，定时删除策略可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存；但另一方面，定时删除策略的缺点是，他对CPU是最不友好的：在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间，在内存不紧张但是CPU时间非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响；

**惰性删除**：

放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，那就返回该键；对CPU时间来说是最友好的：程序只会在取出键时才对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情况下进行；惰性删除策略的缺点是，它对内存是最不友好的：如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放；

**定期删除**：

每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于删除多少过期键，以及要检查多少个数据库，则由算法决定。是前两种策略的一种整合和折中： 定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响； 通过定期删除过期键，定期删除策略有效地减少了因为过期键而带来的内存浪费； 定期删除策略的难点是确定删除操作执行的时长和频率。



**主从复制**

将一台redis服务器的数据复制到其他redis服务器，前者为主节点，后者为从节点。复制是单向的，只能从主节点到从节点。

作用：

数据冗余:实现了数据热备份

故障恢复:主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复

负载均衡:可以设置读写分离，分担redis服务器负载，可以设置多从节点提高并发量

高可用:配合哨兵模式，集群模式可以实现redis高可用



**哨兵模式**

主从复制模式下，如果主节点故障，需要人工操作才能使从节点提供服务。

哨兵模式用来解决这一问题，能够自动完成故障发现与故障转移，并通知可用户端，实现高可用。

由一组哨兵节点(奇数个)和一组或多组主从复制节点组成。

1.每个哨兵节点每秒向其他哨兵节点和所有redis节点发送心跳检测。

2.如果一个redis节点距离最后一次回复心跳检测超过own-after-milliseconds，则认为这个节点主观下线。

3.如果一个Master被认为主观下线，则监测这个master的所有哨兵，以每秒一次的频率发送请求确认状态。

4.有足够多的哨兵(配置文件中配置，一般为哨兵总数/2+1)在指定时间范围内确定master处于主观下线状态，则master被标记为客观下线.

5.所有哨兵选举出一个哨兵，执行故障转移

6.选举出的哨兵，从从节点中选出一个作为主节点，

过滤不健康的节点，选择优先级最高的节点，选择复制偏移量最大的节点，选择runid最小的节点



